### ğŸ§© Code Recap

```python
s = input("Enter a string:")
result = ""
for x in range(len(s)):
    if x % 2 == 0:
        result = result + s[x].upper()
    else:
        result = result + s[x].lower()
print(result)
```

---

## **1ï¸âƒ£ Time Complexity Analysis**

Let the length of the string be **n**.

### Step-by-step:

| Operation                            | Time Cost                         | Frequency        |
| ------------------------------------ | --------------------------------- | ---------------- |
| `len(s)`                             | O(1)                              | once             |
| `for x in range(len(s))`             | O(n) iterations                   | n times          |
| `x % 2`                              | O(1)                              | n times          |
| `s[x].upper()` or `s[x].lower()`     | O(1)                              | n times          |
| **`result = result + s[x].upper()`** | âš ï¸ O(k) (length of result so far) | repeated n times |

---

### ğŸš¨ Key Insight:

`result = result + ...` creates a **new string each time** because Python strings are **immutable**.
Each concatenation copies the old `result` plus one new character â†’ this becomes:

[
O(1 + 2 + 3 + ... + n) = O(n^2)
]

So overall:

âœ… **Time Complexity = O(nÂ²)**

---

### ğŸ§  Optimization

If you use a **list** and join at the end, it becomes linear:

```python
s = input("Enter a string:")
result = []
for x in range(len(s)):
    if x % 2 == 0:
        result.append(s[x].upper())
    else:
        result.append(s[x].lower())
print(''.join(result))
```

Then:
âœ… **Time Complexity = O(n)**
âœ… **Space Complexity = O(n)**

---

## **2ï¸âƒ£ Space Complexity Analysis**

### Breakdown:

| Component                              | Space Used                           |
| -------------------------------------- | ------------------------------------ |
| Input string `s`                       | O(n)                                 |
| Result string                          | O(n) (final output)                  |
| Temporary strings during concatenation | can grow up to O(nÂ²) total over time |
| Variables (`x`, etc.)                  | O(1)                                 |

So:

- In the **original version**: **O(nÂ²)** (because of repeated copies)
- In the **optimized list version**: **O(n)**

---

âœ… **Final Summary**

| Version                                 | Time Complexity | Space Complexity |
| --------------------------------------- | --------------- | ---------------- |
| Original (with `result = result + ...`) | **O(nÂ²)**       | **O(nÂ²)**        |
| Optimized (with list + `''.join`)       | **O(n)**        | **O(n)**         |

---

### ğŸ”¹ Step 1: Key Property â€” Strings are **Immutable**

In Python, strings **cannot be changed** once created.
So every time you â€œmodifyâ€ a string â€” like doing

```python
result = result + s[x]
```

â€” Python actually **creates a brand new string** in memory and **copies over** all the old characters plus the new one.

---

### ğŸ”¹ Step 2: Dry Run Example

Letâ€™s dry-run your loop for
`s = "abcd"`

#### Iteration 1

- `result = ""`
- `x = 0` â†’ `result = "" + "A"`
  â¡ï¸ new string `"A"` created (copies 0 old chars + adds 1 new one).

#### Iteration 2

- `x = 1` â†’ `result = "A" + "b"`
  â¡ï¸ new string `"Ab"` created (copies **1** old char `"A"` + adds `"b"`).

#### Iteration 3

- `x = 2` â†’ `result = "Ab" + "C"`
  â¡ï¸ new string `"AbC"` created (copies **2** old chars `"Ab"` + adds `"C"`).

#### Iteration 4

- `x = 3` â†’ `result = "AbC" + "d"`
  â¡ï¸ new string `"AbCd"` created (copies **3** old chars `"AbC"` + adds `"d"`).

---

### ğŸ”¹ Step 3: Time Complexity Analysis

Look at how many characters are copied each time:

| Iteration | Chars copied | Total so far |
| --------- | ------------ | ------------ |
| 1         | 0            | 0            |
| 2         | 1            | 1            |
| 3         | 2            | 3            |
| 4         | 3            | 6            |

In general, total characters copied =
`0 + 1 + 2 + 3 + â€¦ + (n-1)` = **O(nÂ²)**.

So, **Time Complexity = O(nÂ²)**.

---

### ğŸ”¹ Step 4: Space Complexity Analysis

- Each time, a **new string** is created, but Pythonâ€™s garbage collector frees the old one.
- However, **at peak**, the largest string is of length `n`.
  So, **Space Complexity = O(n)** (for final string).

But internally, many **temporary O(k)** strings (for k < n) are created â€” thatâ€™s why itâ€™s inefficient.

---

### âœ… More Efficient Alternative

You can avoid this repeated copying using a list:

```python
result = []
for x in range(len(s)):
    if x % 2 == 0:
        result.append(s[x].upper())
    else:
        result.append(s[x].lower())

print("".join(result))
```

This version:

- Builds a list incrementally (`append` = O(1))
- Joins once at the end (`O(n)`)

âœ… **Time complexity:** O(n)
âœ… **Space complexity:** O(n)

---
